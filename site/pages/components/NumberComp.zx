
pub const GameXProps = struct { 
    lg_num: i32,
};

pub fn GameX(ctx: *zx.ComponentCtx(GameXProps)) zx.Component {
    if (builtin.cpu.arch == .wasm32) {
        // initOriginalArray();
        initNumArr(zx.client_allocator);
    }
    const sixItems = [_]void{{}, {}, {}, {}, {}, {}};
    
    return (
        <div @allocator={ctx.allocator} lg_num={ctx.props.lg_num} class="number-box bg-white rounded-lg shadow-lg">
            // <h4>{ctx.props.lg_num}</h4>
            
            <div style="margin-bottom: 8px;">
                <span style="color: #ffffff; display: inline-block; min-width: 70px; text-align: center; margin: 3px; padding: 10px 15px; background: #ef233c;  font-size: 18px; font-weight: bold;box-shadow: inset 0 0 10px #000000;">{NumSum}</span>
            </div>

            <div style={getInitialNumStyle()}>
                <ul class="item-list" style="list-style: none; padding: 0; margin: 0;">
                    {for (sixItems) |_| (
                        <span
                        style="color: black; display: inline-block; min-width: 70px; text-align: center; margin: 3px; padding: 10px 15px;  font-size: 16px; font-weight: bold; box-shadow: inset 0 0 20px #a1a1a1;">
                            0
                        </span>
                    )}
                </ul>
            </div>
            <div style={getOriginalNumStyle()}>
                <ul class="item-list" style="list-style: none; padding: 0; margin: 0;">
                    {for (OriginalNumbers.items) |val| (
                        <span
                        style="color: black; display: inline-block; min-width: 70px; text-align: center; margin: 3px; padding: 10px 15px;  font-size: 16px; font-weight: bold; box-shadow: inset 0 0 20px #a1a1a1;">
                            {val}
                        </span>
                    )}
                </ul>
            </div>

            <div style="margin-top: 10px;">
                <Button onclick={BuildNumberSet} id="swaprows" title="Smash ðŸŽ®" />
                <Button onclick={clearRows} id="clear" title="Clear" />
            </div>
            <Card @allocator={ctx.allocator} />

            <div>
                <Hints @allocator={ctx.allocator} hintsShown={hintsShown} totalHints={ResultStoredArray.items.len} hints={ResultStoredArray.items} onShowNext={showNextHintWrapper} />
            </div>
        </div>
    );
}

// Shared styles
const historyRowStyle = "display: flex; gap: 8px; align-items: center; margin-bottom: 6px; padding: 6px; background: #1e293b; border-radius: 6px;";
const historyNumStyle = "color: #ffffff; min-width: 45px; text-align: center; padding: 6px 10px; background: #64748b; border-radius: 5px; font-size: 14px; font-weight: bold;";
const historyOpStyle = "color: #f59e0b; font-size: 16px; font-weight: bold;";
const historyEqStyle = "color: #ffffff; font-size: 16px; font-weight: bold;";
const historyResultStyle = "color: #ffffff; min-width: 45px; text-align: center; padding: 6px 10px; background: #22c55e; border-radius: 5px; font-size: 14px; font-weight: bold;";
const selectedNumStyle = "color: #ffffff; min-width: 55px; text-align: center; padding: 8px 12px; background: #22c55e; border-radius: 6px; font-size: 14px; font-weight: bold;";
const opBtnStyle = "color: #ffffff; min-width: 45px; text-align: center; padding: 8px 12px; background: #f59e0b; border-radius: 6px; font-size: 16px; font-weight: bold; border: none; cursor: pointer;";
const numBtnStyle = "color: #ffffff; min-width: 55px; text-align: center; padding: 8px 12px; background: #3b82f6; border-radius: 6px; font-size: 14px; font-weight: bold; border: none; cursor: pointer;";
const hiddenStyle = "display: none;";

fn Card(allocator: zx.Allocator) zx.Component {
    return (
        <div @allocator={allocator} class="card" style="margin-top: 10px;">
            // Show all calculation history
            
            {for (calcHistory.items) |calc| (
                <div @allocator={allocator} style={historyRowStyle}>
                    <span style={historyNumStyle}>{calc.firstNum}</span>
                    <span style={historyOpStyle}>{calc.operator}</span>
                    <span style={historyNumStyle}>{calc.secondNum}</span>
                    <span style={historyEqStyle}>=</span>
                    <span style={historyResultStyle}>{calc.result}</span>
                </div>
            )}
            
            <div @allocator={allocator} class="w-full" style={selectNumDiv()}>
                <hr class="border-[3px] border-teal-400" />
                <h1 class="text-2xl font-bold text-gray-700 italic font-mono">Select Numbers</h1>
                <hr class="border-[3px] border-teal-400" />
            </div>
            // Finished state
            <div @allocator={allocator} style={getFinishedStyle()}>
                <span style="color: #ffffff; font-size: 18px; font-weight: bold;">âœ“ Finished! Final Result:</span>
                <span style="color: #ffffff; min-width: 60px; text-align: center; padding: 12px 16px; background: #16a34a; border-radius: 8px; font-size: 20px; font-weight: bold;">{getFinalResult()}</span>
                <span style="color: #ffffff; font-size: 18px; font-weight: bold;">Difference</span>
            </div>
            
            // Select first number state
            <div @allocator={allocator} style={getSelectFirstStyle()}>
                <button onclick={handleNum0} style={getNumStyle(0)}>{getNumValue(0)}</button>
                <button onclick={handleNum1} style={getNumStyle(1)}>{getNumValue(1)}</button>
                <button onclick={handleNum2} style={getNumStyle(2)}>{getNumValue(2)}</button>
                <button onclick={handleNum3} style={getNumStyle(3)}>{getNumValue(3)}</button>
                <button onclick={handleNum4} style={getNumStyle(4)}>{getNumValue(4)}</button>
                <button onclick={handleNum5} style={getNumStyle(5)}>{getNumValue(5)}</button>
                <button onclick={handleNum6} style={getNumStyle(6)}>{getNumValue(6)}</button>
                <button onclick={handleNum7} style={getNumStyle(7)}>{getNumValue(7)}</button>
                <button onclick={handleNum8} style={getNumStyle(8)}>{getNumValue(8)}</button>
                <button onclick={handleNum9} style={getNumStyle(9)}>{getNumValue(9)}</button>
            </div>
            
            // Select operator state
            <div @allocator={allocator} style={getSelectOpStyle()}>
                <span style={selectedNumStyle}>{firstNumber}</span>
                <button onclick={handleOpAdd} style={opBtnStyle}>+</button>
                <button onclick={handleOpSub} style={getSubtructButtonStyle()}>-</button>
                <button onclick={handleOpMul} style={opBtnStyle}>Ã—</button>
                <button onclick={handleOpDiv} style={getDivideButtonStyle()}>Ã·</button>
            </div>
            
            // Select second number state
            <div @allocator={allocator} style={getSelectSecondStyle()}>
                <span style={selectedNumStyle}>{firstNumber}</span>
                <span style={opBtnStyle}>{selectedOperator}</span>
                <button onclick={handleSecond0} style={getSecondStyle(0)}>{getNumValue(0)}</button>
                <button onclick={handleSecond1} style={getSecondStyle(1)}>{getNumValue(1)}</button>
                <button onclick={handleSecond2} style={getSecondStyle(2)}>{getNumValue(2)}</button>
                <button onclick={handleSecond3} style={getSecondStyle(3)}>{getNumValue(3)}</button>
                <button onclick={handleSecond4} style={getSecondStyle(4)}>{getNumValue(4)}</button>
                <button onclick={handleSecond5} style={getSecondStyle(5)}>{getNumValue(5)}</button>
                <button onclick={handleSecond6} style={getSecondStyle(6)}>{getNumValue(6)}</button>
                <button onclick={handleSecond7} style={getSecondStyle(7)}>{getNumValue(7)}</button>
                <button onclick={handleSecond8} style={getSecondStyle(8)}>{getNumValue(8)}</button>
                <button onclick={handleSecond9} style={getSecondStyle(9)}>{getNumValue(9)}</button>
            </div>
        </div>
    );
}

// Wrapper function for hint callback
fn showNextHintWrapper() void {
    if (hintsShown < ResultStoredArray.items.len) {
        hintsShown += 1;
        zx.requestRender();
    }
}

// Show hints components codes
var ResultStoredArray = std.ArrayList(HintItem).empty;
var Skippedlist = std.ArrayList(u32).empty;


// State visibility helpers
fn getFinishedStyle() []const u8 {

    if ( NumArr.items.len > 0 ) CopyNumArr = NumArr;

    const now_final_result = getFinalResult();
    if ( (now_final_result == 0 and countAvailable() != 0 ) or (countAvailable() <= 1 and calcHistory.items.len > 0)) {
        NumArr.clearRetainingCapacity();
        return "display: flex; gap: 10px; align-items: center; padding: 15px; background: #22c55e; border-radius: 8px;";
    }
    return hiddenStyle;
}

fn selectNumDiv() []const u8 {
    if (countAvailable() <= 0) {
        return hiddenStyle;
    }
    return "display: block; text-align: center;";
}

fn getInitialNumStyle() []const u8 {
    if (NumArr.items.len == 0) return "display: block;";
    return hiddenStyle;
}

fn getOriginalNumStyle() []const u8 {
    if (NumArr.items.len > 0) return "display: block;";
    return hiddenStyle;
}

fn getSelectFirstStyle() []const u8 {
    if (countAvailable() <= 1 and calcHistory.items.len > 0) return hiddenStyle;
    if (currentState == .SelectFirstNumber) return "display: flex; gap: 10px; flex-wrap: wrap;";
    return hiddenStyle;
}

fn getSelectOpStyle() []const u8 {
    if (currentState == .SelectOperator) return "display: flex; gap: 10px; align-items: center;";
    return hiddenStyle;
}

fn getSelectSecondStyle() []const u8 {
    if (currentState == .SelectSecondNumber) return "display: flex; gap: 10px; align-items: center; flex-wrap: wrap;";
    return hiddenStyle;
}

fn getNumValue(idx: usize) u32 {
    if (idx < NumArr.items.len) return NumArr.items[idx].value;
    return 0;
}

fn getNumStyle(idx: usize) []const u8 {
    if (idx < NumArr.items.len and !NumArr.items[idx].isUsed) return numBtnStyle;
    return hiddenStyle;
}

fn getSecondStyle(idx: usize) []const u8 {
    if (idx >= NumArr.items.len or NumArr.items[idx].isUsed or idx == firstNumberIdx) return hiddenStyle;
    
    // subtruct op is selected, show smaller numbers

    if (selectedOperatorIdx == 1) {
        const val = NumArr.items[idx].value;

        if (val != 0 and firstNumber > val){
            return numBtnStyle;
        }
        return hiddenStyle;
    }

    // If divide operator is selected, only show divisors
    if (selectedOperatorIdx == 3) {
        const val = NumArr.items[idx].value;
        if (val != 0 and firstNumber % val == 0) {
            return numBtnStyle;
        }
        return hiddenStyle;
    }
    
    return numBtnStyle;
}

fn getSubtructButtonStyle() []const u8 {
    if (currentState != .SelectOperator) return hiddenStyle;

    for (NumArr.items, 0..) |item, idx| {
        if (!item.isUsed and idx != firstNumberIdx and item.value != 0) {
            if(firstNumber > item.value) {
                return opBtnStyle;
            }
        }
    }
    return hiddenStyle;
}

fn getDivideButtonStyle() []const u8 {
    if (currentState != .SelectOperator) return hiddenStyle;
    
    // Check if firstNumber is divisible by any available number
    for (NumArr.items, 0..) |item, idx| {
        if (!item.isUsed and idx != firstNumberIdx and item.value != 0) {
            if (firstNumber % item.value == 0) {
                return opBtnStyle;
            }
        }
    }
    return hiddenStyle;
}

fn countAvailable() usize {
    var count: usize = 0;
    for (CopyNumArr.items) |item| {
        if (!item.isUsed) count += 1;
    }
    return count;
}

fn getFinalResult() u32 {
    for (CopyNumArr.items) |item| {
        if (!item.isUsed) {
            // Absolute difference
            return if (NumSum >= item.value) NumSum - item.value else item.value - NumSum;
        }
    }
    return 0;
}

fn calculate(a: u32, b: u32, opIdx: usize) u32 {
    return switch (opIdx) {
        0 => a + b,                                    // +
        1 => if (a >= b) a - b else b - a,            // -
        2 => a * b,                                    // Ã—
        3 => if (b != 0) a / b else 0,                // Ã·
        else => 0,
    };
}

fn selectNumber(idx: usize) void {
    if (idx < NumArr.items.len and !NumArr.items[idx].isUsed) {
        firstNumber = NumArr.items[idx].value;
        firstNumberIdx = idx;
        currentState = .SelectOperator;
        zx.requestRender();
    }
}

fn handleNum0(_: zx.EventContext) void { selectNumber(0); }
fn handleNum1(_: zx.EventContext) void { selectNumber(1); }
fn handleNum2(_: zx.EventContext) void { selectNumber(2); }
fn handleNum3(_: zx.EventContext) void { selectNumber(3); }
fn handleNum4(_: zx.EventContext) void { selectNumber(4); }
fn handleNum5(_: zx.EventContext) void { selectNumber(5); }
fn handleNum6(_: zx.EventContext) void { selectNumber(6); }
fn handleNum7(_: zx.EventContext) void { selectNumber(7); }
fn handleNum8(_: zx.EventContext) void { selectNumber(8); }
fn handleNum9(_: zx.EventContext) void { selectNumber(9); }

fn selectSecondNumber(idx: usize) void {
    if (idx >= NumArr.items.len or NumArr.items[idx].isUsed or idx == firstNumberIdx) return;
    
    const secondNumber = NumArr.items[idx].value;
    const result = calculate(firstNumber, secondNumber, selectedOperatorIdx);
    
    // Add to calculation history
    calcHistory.append(NumArr_allocator, .{
        .firstNum = firstNumber,
        .secondNum = secondNumber,
        .operator = selectedOperator,
        .result = result,
    }) catch @panic("OOM");
    
    // Mark both numbers as used
    NumArr.items[firstNumberIdx].isUsed = true;
    NumArr.items[idx].isUsed = true;
    
    // Add result as new number
    const newItem = Item{ .value = result, .isUsed = false, .isOriginal = false };
    NumArr.append(NumArr_allocator, newItem) catch @panic("OOM");
    
    currentState = .SelectFirstNumber;
    sortNumbers();
    zx.requestRender();
}

fn handleSecond0(_: zx.EventContext) void { selectSecondNumber(0); }
fn handleSecond1(_: zx.EventContext) void { selectSecondNumber(1); }
fn handleSecond2(_: zx.EventContext) void { selectSecondNumber(2); }
fn handleSecond3(_: zx.EventContext) void { selectSecondNumber(3); }
fn handleSecond4(_: zx.EventContext) void { selectSecondNumber(4); }
fn handleSecond5(_: zx.EventContext) void { selectSecondNumber(5); }
fn handleSecond6(_: zx.EventContext) void { selectSecondNumber(6); }
fn handleSecond7(_: zx.EventContext) void { selectSecondNumber(7); }
fn handleSecond8(_: zx.EventContext) void { selectSecondNumber(8); }
fn handleSecond9(_: zx.EventContext) void { selectSecondNumber(9); }




const Item = struct { value: u32, isUsed: bool, isOriginal: bool };

// Calculation history entry
const CalcEntry = struct {
    firstNum: u32,
    secondNum: u32,
    operator: []const u8,
    result: u32,
};

// State machine for the game flow
const GameState = enum {
    SelectFirstNumber,
    SelectOperator,
    SelectSecondNumber,
};

var NumArr = std.ArrayList(Item).empty;
var CopyNumArr = std.ArrayList(Item).empty;
var OriginalNumbers = std.ArrayList(u32).empty;
var NumSum: u32 = 0;
var NumArr_allocator: std.mem.Allocator = undefined;
var initialized: bool = false;

// Game state variables
var currentState: GameState = .SelectFirstNumber;
var firstNumber: u32 = 0;
var firstNumberIdx: usize = 0;
var selectedOperator: []const u8 = "+";
var selectedOperatorIdx: usize = 0;

// Calculation history
var calcHistory = std.ArrayList(CalcEntry).empty;

// Hints tracking
var hintsShown: usize = 0;

var seed: u32 = 12345;
var clickCount: u32 = 0;

fn RandomNumber(max: u32) u32 {
    seed = seed *% 1103515245 +% 12345;
    return seed % max;
}

fn initNumArr(allocator: zx.Allocator) void {
    if (initialized) return;
    initialized = true;
    NumArr_allocator = allocator;
    NumArr = std.ArrayList(Item).empty;
    
    // Initialize with zeros for initial display
    for (0..6) |_| {
        OriginalNumbers.append(NumArr_allocator, 0) catch @panic("OOM");
    }
}



const small_num = [_]u32{ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10 };
const big_num = [_]u32{ 25, 50, 75, 100 };
const operators = [_][]const u8{ "+", "-", "Ã—", "Ã·" };
fn BuildNumberSet(_: zx.EventContext) void {
    NumArr.clearRetainingCapacity();
    OriginalNumbers.clearRetainingCapacity();
    calcHistory.clearRetainingCapacity();
    currentState = .SelectFirstNumber;
    NumSum = 0;
    hintsShown = 0;

    
    // Track used indices for small_num
    var used_small = [_]bool{false} ** small_num.len;
    for (0..5) |_| {
        var idx = RandomNumber(small_num.len);
        // Find an unused index
        while (used_small[idx]) {
            idx = RandomNumber(small_num.len);
        }
        used_small[idx] = true;
        
        const get_val = small_num[idx];
        const item = Item{
            .value = get_val,
            .isUsed = false,
            .isOriginal = true,
        };
        NumArr.append(NumArr_allocator, item) catch @panic("OOM");
        // NumSum += get_val;
    }
    
    // Track used indices for big_num
    var used_big = [_]bool{false} ** big_num.len;
    for (0..1) |_| {
        var idx = RandomNumber(big_num.len);
        // Find an unused index
        while (used_big[idx]) {
            idx = RandomNumber(big_num.len);
        }
        used_big[idx] = true;
        
        const get_val = big_num[idx];
        const item = Item{
            .value = get_val,
            .isUsed = false,
            .isOriginal = true,
        };
        NumArr.append(NumArr_allocator, item) catch @panic("OOM");
        // NumSum += get_val;
    }

    makeResultWithRandomOperator();
    
    // Save and sort original numbers once for top display
    for (NumArr.items) |item| {
        OriginalNumbers.append(NumArr_allocator, item.value) catch @panic("OOM");
    }
    std.mem.sort(u32, OriginalNumbers.items, {}, struct {
        fn lessThan(_: void, a: u32, b: u32) bool {
            return a > b;
        }
    }.lessThan);
    
    sortNumbers();
    zx.requestRender();
}


fn makeResultWithRandomOperator() void {
    if (NumArr.items.len == 0) return;
    
    while(NumSum < 100 or NumSum > 999){
        ResultStoredArray.clearRetainingCapacity();
        Skippedlist.clearRetainingCapacity();
        NumSum = NumArr.items[0].value;
        
        for (NumArr.items[1..]) |val| {
            const op = RandomNumber(3);
            const first_num = NumSum;
            const skiped_val = val.value;
            switch (op) {
                0 => NumSum +%= val.value,  // wrapping add
                1 => {
                    if (NumSum >= val.value) {
                        NumSum -= val.value;
                    } else {
                        Skippedlist.append(NumArr_allocator, skiped_val) catch @panic("OOM");
                        continue;
                    }
                },
                2 => NumSum *%= val.value,  // wrapping multiply
                else => {
                    if (val.value != 0 and NumSum % val.value == 0) {
                        NumSum /= val.value;
                    }
                    else{
                        Skippedlist.append(NumArr_allocator, skiped_val) catch @panic("OOM");
                        continue;
                    }
                },


            }
            // storing results................................
            const getItems = HintItem{
                .num1 = first_num,
                .num2 = val.value,
                .expression = operators[op],
                .result = NumSum,
                .isSkipped = false,
            };
            ResultStoredArray.append(NumArr_allocator, getItems) catch @panic("OOM");
            // ...............................................
        }
    }
    
    // After the loop, add skipped values as hints at the beginning
    if (Skippedlist.items.len > 0) {
        // Create a temporary array to hold all hints
        var tempHints = std.ArrayList(HintItem).empty;
        
        // First, add all skipped values as special hints
        for (Skippedlist.items) |skipped| {
            const skippedHint = HintItem{
                .num1 = 0,
                .num2 = 0,
                .expression = "",
                .result = skipped,
                .isSkipped = true,
            };
            tempHints.append(NumArr_allocator, skippedHint) catch @panic("OOM");
        }
        
        // Then add all the calculation hints
        for (ResultStoredArray.items) |hint| {
            tempHints.append(NumArr_allocator, hint) catch @panic("OOM");
        }
        
        // Replace ResultStoredArray with the reordered hints
        ResultStoredArray.clearRetainingCapacity();
        for (tempHints.items) |hint| {
            ResultStoredArray.append(NumArr_allocator, hint) catch @panic("OOM");
        }
    }

}


fn initOriginalArray() void {
    for(1..7) |_|{
        OriginalNumbers.append(NumArr_allocator, 0) catch @panic("OOM");
    }
}



fn clearRows(_: zx.EventContext) void {
    NumArr.clearRetainingCapacity();
    OriginalNumbers.clearRetainingCapacity();
    ResultStoredArray.clearRetainingCapacity();
    initOriginalArray();


    calcHistory.clearRetainingCapacity();
    NumSum = 0;
    currentState = .SelectFirstNumber;
    hintsShown = 0;
    zx.requestRender();
}

fn sortNumbers() void {
    std.mem.sort(Item, NumArr.items, {}, struct {
        fn lessThan(_: void, a: Item, b: Item) bool {
            // Sort unused numbers first, then by value descending
            if (a.isUsed != b.isUsed) {
                return !a.isUsed; // unused comes first
            }
            return a.value > b.value;
        }
    }.lessThan);
}

fn selectOperator(op: []const u8, idx: usize) void {
    selectedOperator = op;
    selectedOperatorIdx = idx;
    currentState = .SelectSecondNumber;
    zx.requestRender();
}

fn handleOpAdd(_: zx.EventContext) void { selectOperator("+", 0); }
fn handleOpSub(_: zx.EventContext) void { selectOperator("-", 1); }
fn handleOpMul(_: zx.EventContext) void { selectOperator("Ã—", 2); }
fn handleOpDiv(_: zx.EventContext) void { selectOperator("Ã·", 3); }



const zx = @import("zx");
const std = @import("std");
const builtin = @import("builtin");
pub const Button = @import("./ButtonComp.zig").Button;
const HintComp = @import("./HintComp.zx");
pub const Hints = HintComp.Hints;
const HintItem = HintComp.HintItem;
