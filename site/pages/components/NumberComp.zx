
pub const NumberProps = struct { 
    lg_num: i32,
};

pub fn Number(ctx: *zx.ComponentCtx(NumberProps)) zx.Component {
    if (builtin.cpu.arch == .wasm32) {
        initNumArr(zx.client_allocator);
    }
    
    return (
        <div @allocator={ctx.allocator} lg_num={ctx.props.lg_num} class="number-box bg-gray-900 p-4 m-2 rounded-lg">
            // <h4>{ctx.props.lg_num}</h4>
            
            <div style="margin-bottom: 15px;">
                <span style="color: #ffffff; display: inline-block; min-width: 80px; text-align: center; margin: 5px; padding: 15px 20px; background: #ef233c; border-radius: 8px; font-size: 20px; font-weight: bold;">{NumSum}</span>
            </div>

            <div>
                <ul class="item-list" style="list-style: none; padding: 0; margin: 0;">
                    {for (NumArr.items) |item| (
                        <span style="color: #ffffff; display: inline-block; min-width: 80px; text-align: center; margin: 5px; padding: 15px 20px; background: #a5a5a5; border-radius: 8px; font-size: 18px; font-weight: bold;">{item.value}</span>
                    )}
                </ul>
            </div>

            <div style="margin-top: 20px;">
                <Button onclick={BuildNumberSet} id="swaprows" title="Smash!" />
                <Button onclick={clearRows} id="clear" title="Clear" />
            </div>
            
        </div>
    );
}




const Item = struct { value: u32, isUsed: bool };

var NumArr = std.ArrayList(Item).empty;
var NumSum: u32 = 0;
var NumArr_allocator: std.mem.Allocator = undefined;
var initialized: bool = false;


var seed: u32 = 12345;
fn RandomNumber(max: u32) u32 {
    seed = seed *% 1103515245 +% 12345;
    return seed % max;
}

fn initNumArr(allocator: zx.Allocator) void {
    if (initialized) return;
    initialized = true;
    NumArr_allocator = allocator;
    NumArr = std.ArrayList(Item).empty;

    // seed = @truncate(@as(u64, @intCast(std.time.milliTimestamp())));

}



const small_num = [_]u32{ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10 };
const big_num = [_]u32{ 25, 50, 75, 100 };

fn BuildNumberSet(_: zx.EventContext) void {
    NumArr.clearRetainingCapacity();
    NumSum = 0;
    // seed +%= 7919;
    for (0..5) |_| {
        const get_val = small_num[RandomNumber(small_num.len)];
        const item = Item{
            .value = get_val,
            .isUsed = false,
        };
        NumArr.append(NumArr_allocator, item) catch @panic("OOM");
        NumSum += get_val;
    }
    for (0..1) |_| {
        const get_val = big_num[RandomNumber(big_num.len)];
        const item = Item{
            .value = get_val,
            .isUsed = false,
        };
        NumArr.append(NumArr_allocator, item) catch @panic("OOM");
        NumSum += get_val;
    }
    std.mem.sort(Item, NumArr.items, {}, struct {
        fn lessThan(_: void, a: Item, b: Item) bool {
            return a.value > b.value;
        }
    }.lessThan);
    zx.requestRender();
}

fn clearRows(_: zx.EventContext) void {
    NumArr.clearRetainingCapacity();
    NumSum = 0;
    zx.requestRender();
}






const zx = @import("zx");
const std = @import("std");
const builtin = @import("builtin");
pub const Button = @import("./ButtonComp.zig").Button;
